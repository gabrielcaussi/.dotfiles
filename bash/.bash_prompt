# setup variables
if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
  color_is_on=true
  color_black="\[$(/usr/bin/tput setaf 0)\]"
  color_red="\[$(/usr/bin/tput setaf 1)\]"
  color_green="\[$(/usr/bin/tput setaf 2)\]"
  color_yellow="\[$(/usr/bin/tput setaf 3)\]"
  color_blue="\[$(/usr/bin/tput setaf 4)\]"
  color_majenta="\[$(/usr/bin/tput setaf 5)\]"
  color_cyan="\[$(/usr/bin/tput setaf 6)\]"
  color_white="\[$(/usr/bin/tput setaf 7)\]"
  color_off="\[$(/usr/bin/tput sgr0)\]"
  color_error="$(/usr/bin/tput setab 1)$(/usr/bin/tput setaf 7)"
  color_error_off="$(/usr/bin/tput sgr0)"
  bold="$(/usr/bin/tput bold)"
fi

# Symbols
prompt_symbol="$"
prompt_clean_symbol=""
prompt_dirty_symbol="âœ—"

function prompt_command() {
  # Local or SSH session?
  local remote=
  [ -n "$SSH_CLIENT" ] || [ -n "$SSH_TTY" ] && remote=1

  # Git branch name and work tree status (only when we are inside Git working tree)
  local git_prompt=
  if [[ "true" = "$(git rev-parse --is-inside-work-tree 2>/dev/null)" ]]; then
    # Branch name
    local branch="$(git symbolic-ref HEAD 2>/dev/null)"
    branch="${branch##refs/heads/}"

    # Working tree status (red when dirty)
    local dirty=
    # Modified files
    git diff --no-ext-diff --quiet --exit-code --ignore-submodules 2>/dev/null || dirty=1
    # Untracked files
    [ -z "$dirty" ] && test -n "$(git status --porcelain)" && dirty=1

    # Format Git info
    if [ -n "$dirty" ]; then
      git_prompt="$color_red$branch $color_yellow$prompt_dirty_symbol$color_off"
    else
      git_prompt="$color_red$branch $prompt_clean_symbol$color_off"
    fi
  fi

  # Format prompt
	PS1="\n$color_blue$bold\w $color_red$bold$git_prompt\n$color_green$bold$prompt_symbol$color_off "
}

# Show awesome prompt only if Git is istalled
command -v git >/dev/null 2>&1 && PROMPT_COMMAND=prompt_command
